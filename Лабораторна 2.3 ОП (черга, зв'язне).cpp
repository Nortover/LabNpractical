/**
 * Зроблено:
 * Ім'я студента: Пушко Станіслав
 * Група студента: 121
 * Лабораторна 2.3
 */

#include <iostream>

const int N = 8; // кількість елементів, що додаються до черги
const int M = 4;// кількість елементів, що видаляються з черги
const int size = 10; // максимальна кількість черги

struct Queue //опис елемента черги в зв’язному представленні
{
	char data;//значення елемента (символьне)
	Queue* next;//посилання на наступний елемент черги
};

int main()
{
	int arr[size] = { 1,2,2,3,3,4,5,3,6,5 };//масив, з якого беремо значення
	Queue* head = NULL;//створюємо позицію першого елемента черги і задаємо початкове значення 0
	Queue* tail = NULL;//створюємо позицію останнього елемента черги і задаємо початкове значення 0
	for (int i = 0; i < N && i < size; i++)//додаємо елементи до черги (в кінець)
	{
		Queue* cur = new Queue;//створюємо новий елемент, виділяємо на нього пам'ять 
		cur->data = arr[i];//присвоюємо елементу значення з масиву
		cur->next = NULL;//так як додаємо в кінець, доданий елемент буде мати посилання 0
		if (head == NULL)//якщо черга була порожня і ми додаємо перший елемент
		{
			head = cur;//доданий елемент займає позицію першого
			tail = cur;//і останнього елемента черги
		}
		else//якщо черга не була порожня 
		{
			tail->next = cur;//останній елемент в черзі посилатиметься на щойно доданий
			tail = cur;// доданий елемент займає позицію останнього елемента
		}
	}
	for (int i = 0; i < M && head != NULL; i++)//видалення елементів з черги (з голови)
	{
		Queue* temp = head;//створюємо тимчасову змінну, в яку записуємо посилання на перший елемент черги
		head = head->next;//першому елементу присвоюємо посилання на наступний після першого елемент, т.б. адресу другого елемента
		delete temp;//стираємо значення першого елемента
	}
}

